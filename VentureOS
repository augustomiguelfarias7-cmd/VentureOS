#!/usr/bin/env bash
# oscore_advanced_all_in_one.sh
# ÚNICO ARQUIVO: gera projeto 'oscore-advanced' com liboscore (C), netlink/uevent monitor,
# pkgmanager auto-install, JNI skeleton, wrappers C++, systemd unit templates e scripts de build.
#
# Uso:
#   chmod +x oscore_advanced_all_in_one.sh
#   ./oscore_advanced_all_in_one.sh
#
# Depois:
#   cd oscore-advanced
#   ./build.sh
#
# Augusto: salva, roda e me fala quando quiser que eu escreva a interface Java/Kotlin (600/1000 linhas).

set -e

ROOT="oscore-advanced"
echo "Gerando projeto avançado em ./${ROOT} ..."
rm -rf "${ROOT}"
mkdir -p "${ROOT}/src" "${ROOT}/src/monitor" "${ROOT}/cpp" "${ROOT}/java/com/example/oscore" "${ROOT}/java/native" "${ROOT}/kotlin/src" "${ROOT}/pkgmanager" "${ROOT}/apps" "${ROOT}/units"

##############################
# README
##############################
cat > "${ROOT}/README.md" <<'EOF'
OSCore Advanced - Projeto gerado por script único

Conteúdo:
- liboscore (C) com monitor netlink/uevent (sem libudev/libnl de alto nível)
- pkgmanager shell (auto-install apps na primeira inicialização)
- placeholders de apps: settings, mail, firefox (instalador tenta usar apt/dnf/pacman)
- JNI/Java/Kotlin skeleton
- CMake + build script
- systemd unit templates (não ativados automaticamente)

AVISO:
- Leia as notas legais sobre GPL e distribuição se for comercializar.
- O script NÃO envia nada pela rede por si só (exceto o instalador que, se for executado, pode chamar apt/curl — use com cuidado).
EOF

##############################
# liboscore.h
##############################
cat > "${ROOT}/src/liboscore.h" <<'EOF'
#ifndef LIBOSCORE_H
#define LIBOSCORE_H

#ifdef __cplusplus
extern "C" {
#endif

/* Inicialização e finalização */
int oscore_init(void);
void oscore_shutdown(void);

/* Uptime (segundos) - lê /proc/uptime */
long oscore_get_uptime_seconds(void);

/* Informações de CPU, Memória */
int oscore_get_meminfo(char *buffer, int bufsize);
int oscore_get_cpuinfo(char *buffer, int bufsize);

/* Lista dispositivos de bloco via /sys/block */
int oscore_list_block_devices(char *buffer, int bufsize);

/* Lista pontos de montagem (/proc/mounts) */
int oscore_list_mounts(char *buffer, int bufsize);

/* Lista interfaces de rede (nome, MAC, IPv4) usando sysfs+ioctl */
int oscore_list_net_interfaces(char *buffer, int bufsize);

/* Executa um comando e retorna saída (debug/admin) */
int oscore_run_command(const char *cmd, char *outbuf, int bufsize);

/* EVENT MONITOR (netlink/uevent):
   Start/stop monitor thread. Events são gravados em um log file (path).
   Retorna 0 em sucesso. */
int oscore_start_event_monitor(const char *event_log_path);
int oscore_stop_event_monitor(void);

/* Versão */
const char *oscore_version(void);

#ifdef __cplusplus
}
#endif

#endif // LIBOSCORE_H
EOF

##############################
# netlink monitor (monitor/netlink_monitor.c)
##############################
cat > "${ROOT}/src/monitor/netlink_monitor.c" <<'EOF'
/*
 netlink_monitor.c
 - Abre sockets NETLINK_KOBJECT_UEVENT (uevent) e NETLINK_ROUTE (rtnetlink)
 - Recebe mensagens e grava em um log file
 - Executa em thread separada; expõe função main para ser usada pela lib
*/
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/types.h>
#include <fcntl.h>
#include <time.h>

static volatile int netlink_monitor_running = 0;
static pthread_t netlink_thread;
static char global_event_log_path[1024] = "/tmp/oscore_events.log";

static int open_netlink_socket(int protocol, int groups) {
    int sock = socket(AF_NETLINK, SOCK_RAW, protocol);
    if (sock < 0) return -1;
    struct sockaddr_nl addr;
    memset(&addr, 0, sizeof(addr));
    addr.nl_family = AF_NETLINK;
    addr.nl_groups = groups;
    if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        close(sock);
        return -1;
    }
    return sock;
}

static void write_event(const char *s) {
    int fd = open(global_event_log_path, O_WRONLY | O_CREAT | O_APPEND, 0644);
    if (fd < 0) return;
    dprintf(fd, "%s\n", s);
    close(fd);
}

static void process_uevent_msg(const char *buf, int len) {
    // uevent is a sequence of null-terminated strings
    time_t now = time(NULL);
    char header[128];
    struct tm tm;
    localtime_r(&now, &tm);
    strftime(header, sizeof(header), "[%Y-%m-%d %H:%M:%S] UEV:", &tm);
    write_event(header);
    // write payload
    int pos = 0;
    while (pos < len) {
        int l = strlen(buf + pos);
        if (l == 0) { pos++; continue; }
        int fd = open(global_event_log_path, O_WRONLY | O_CREAT | O_APPEND, 0644);
        if (fd >= 0) {
            dprintf(fd, "  %s\n", buf + pos);
            close(fd);
        }
        pos += l + 1;
    }
}

static void process_rtnetlink_msg(const char *buf, int len) {
    time_t now = time(NULL);
    char header[128];
    struct tm tm;
    localtime_r(&now, &tm);
    strftime(header, sizeof(header), "[%Y-%m-%d %H:%M:%S] RTNL:", &tm);
    write_event(header);
    // naive dump of binary payload as text (for prototype)
    int fd = open(global_event_log_path, O_WRONLY | O_CREAT | O_APPEND, 0644);
    if (fd >= 0) {
        dprintf(fd, "  raw_len=%d\n", len);
        close(fd);
    }
}

static void* netlink_thread_fn(void *arg) {
    (void)arg;
    int sock_uevent = open_netlink_socket(NETLINK_KOBJECT_UEVENT, 1);
    int sock_rtnl = open_netlink_socket(NETLINK_ROUTE, RTMGRP_LINK | RTMGRP_IPV4_IFADDR);
    if (sock_uevent < 0 && sock_rtnl < 0) {
        write_event("[ERROR] failed to open any netlink sockets");
        netlink_monitor_running = 0;
        return NULL;
    }
    netlink_monitor_running = 1;
    write_event("[INFO] netlink monitor started");
    fd_set rfds;
    int maxfd = (sock_uevent > sock_rtnl ? sock_uevent : sock_rtnl) + 1;
    while (netlink_monitor_running) {
        FD_ZERO(&rfds);
        if (sock_uevent >= 0) FD_SET(sock_uevent, &rfds);
        if (sock_rtnl >= 0) FD_SET(sock_rtnl, &rfds);
        struct timeval tv = {1, 0}; // 1s timeout
        int ret = select(maxfd, &rfds, NULL, NULL, &tv);
        if (ret < 0) break;
        if (ret == 0) continue;
        if (sock_uevent >= 0 && FD_ISSET(sock_uevent, &rfds)) {
            char buf[4096];
            int len = recv(sock_uevent, buf, sizeof(buf)-1, 0);
            if (len > 0) {
                buf[len] = '\\0';
                process_uevent_msg(buf, len);
            }
        }
        if (sock_rtnl >= 0 && FD_ISSET(sock_rtnl, &rfds)) {
            char buf[8192];
            int len = recv(sock_rtnl, buf, sizeof(buf), 0);
            if (len > 0) {
                process_rtnetlink_msg(buf, len);
            }
        }
    }
    if (sock_uevent >= 0) close(sock_uevent);
    if (sock_rtnl >= 0) close(sock_rtnl);
    write_event("[INFO] netlink monitor stopped");
    netlink_monitor_running = 0;
    return NULL;
}

/* exposed functions */
int nm_start(const char *event_log_path) {
    if (global_event_log_path && event_log_path) {
        strncpy(global_event_log_path, event_log_path, sizeof(global_event_log_path)-1);
        global_event_log_path[sizeof(global_event_log_path)-1] = '\\0';
    }
    if (netlink_monitor_running) return 0;
    if (pthread_create(&netlink_thread, NULL, netlink_thread_fn, NULL) != 0) return -1;
    return 0;
}

int nm_stop(void) {
    if (!netlink_monitor_running) return 0;
    netlink_monitor_running = 0;
    pthread_join(netlink_thread, NULL);
    return 0;
}
EOF

##############################
# liboscore.c (enhanced)
##############################
cat > "${ROOT}/src/liboscore.c" <<'EOF'
#define _GNU_SOURCE
#include "liboscore.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <errno.h>
#include <pthread.h>

/* forward declarations for netlink monitor functions (from monitor) */
int nm_start(const char *event_log_path);
int nm_stop(void);

int oscore_init(void){
    /* placeholder init */
    return 0;
}
void oscore_shutdown(void){
    nm_stop();
}

/* uptime */
long oscore_get_uptime_seconds(void){
    FILE *f = fopen("/proc/uptime", "r");
    if(!f) return -1;
    double up = 0.0;
    if(fscanf(f, "%lf", &up) != 1){
        fclose(f);
        return -1;
    }
    fclose(f);
    return (long)up;
}

/* meminfo */
int oscore_get_meminfo(char *buffer, int bufsize){
    FILE *f = fopen("/proc/meminfo", "r");
    if(!f) return -1;
    int written = fread(buffer, 1, bufsize-1, f);
    buffer[(written>0 && written < bufsize)?written:bufsize-1] = '\\0';
    fclose(f);
    return written;
}

/* cpuinfo */
int oscore_get_cpuinfo(char *buffer, int bufsize){
    FILE *f = fopen("/proc/cpuinfo", "r");
    if(!f) return -1;
    int written = fread(buffer, 1, bufsize-1, f);
    buffer[(written>0 && written < bufsize)?written:bufsize-1] = '\\0';
    fclose(f);
    return written;
}

/* block devices: /sys/block */
int oscore_list_block_devices(char *buffer, int bufsize){
    const char *path = "/sys/block";
    DIR *d = opendir(path);
    if(!d){
        int n = snprintf(buffer, bufsize, "/dev/sda\n/dev/sdb\n");
        return (n>0)?n:0;
    }
    struct dirent *entry;
    int written = 0;
    while((entry = readdir(d))){
        if(entry->d_name[0] == '.') continue;
        int remain = bufsize - written;
        if(remain <= 1) break;
        char devpath[256];
        snprintf(devpath, sizeof(devpath), "/dev/%s\n", entry->d_name);
        int n = snprintf(buffer + written, remain, "%s", devpath);
        if(n < 0) break;
        written += (n < remain) ? n : (remain-1);
    }
    closedir(d);
    return written;
}

/* mounts: /proc/mounts */
int oscore_list_mounts(char *buffer, int bufsize){
    FILE *f = fopen("/proc/mounts", "r");
    if(!f) return -1;
    int written = fread(buffer, 1, bufsize-1, f);
    buffer[(written>0 && written < bufsize)?written:bufsize-1] = '\\0';
    fclose(f);
    return written;
}

/* net interfaces using /sys/class/net + ioctl */
int oscore_list_net_interfaces(char *buffer, int bufsize){
    const char *path = "/sys/class/net";
    DIR *d = opendir(path);
    if(!d) return -1;
    struct dirent *entry;
    int written = 0;
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if(sock < 0){ closedir(d); return -1; }
    while((entry = readdir(d))){
        if(entry->d_name[0] == '.') continue;
        char name[IFNAMSIZ];
        strncpy(name, entry->d_name, IFNAMSIZ-1);
        name[IFNAMSIZ-1] = '\\0';
        char macpath[256];
        snprintf(macpath, sizeof(macpath), "/sys/class/net/%s/address", name);
        char mac[64] = {0};
        FILE *mf = fopen(macpath, "r");
        if(mf){
            if(fgets(mac, sizeof(mac), mf)){
                size_t L = strlen(mac);
                if(L && mac[L-1] == '\\n') mac[L-1] = '\\0';
            }
            fclose(mf);
        } else {
            strncpy(mac, "00:00:00:00:00:00", sizeof(mac)-1);
        }
        struct ifreq ifr;
        memset(&ifr, 0, sizeof(ifr));
        strncpy(ifr.ifr_name, name, IFNAMSIZ-1);
        char ip[INET_ADDRSTRLEN] = {0};
        if(ioctl(sock, SIOCGIFADDR, &ifr) == 0){
            struct sockaddr_in *sa = (struct sockaddr_in *)&ifr.ifr_addr;
            inet_ntop(AF_INET, &sa->sin_addr, ip, sizeof(ip));
        } else {
            strcpy(ip, "0.0.0.0");
        }
        int remain = bufsize - written;
        if(remain <= 1) break;
        int n = snprintf(buffer + written, remain, "%s %s %s\n", name, mac, ip);
        if(n < 0) break;
        written += (n < remain) ? n : (remain-1);
    }
    close(sock);
    closedir(d);
    return written;
}

/* run command */
int oscore_run_command(const char *cmd, char *outbuf, int bufsize){
    if(!cmd || !outbuf || bufsize <= 0) return -1;
    FILE *p = popen(cmd, "r");
    if(!p) return -1;
    int total = 0;
    while(!feof(p) && total < bufsize-1){
        int r = fread(outbuf + total, 1, bufsize-1-total, p);
        if(r <= 0) break;
        total += r;
    }
    outbuf[total] = '\\0';
    pclose(p);
    return total;
}

/* start/stop event monitor (delegate to netlink monitor implementation) */
int oscore_start_event_monitor(const char *event_log_path){
    return nm_start(event_log_path);
}
int oscore_stop_event_monitor(void){
    return nm_stop();
}

const char *oscore_version(void){
    return "oscore-advanced-1.0";
}
EOF

##############################
# C++ wrapper
##############################
cat > "${ROOT}/cpp/oscore.hpp" <<'EOF'
#pragma once
#include <string>
extern "C" {
#include "../src/liboscore.h"
}
namespace oscore {
class OSCore {
public:
    OSCore(){ oscore_init(); }
    ~OSCore(){ oscore_shutdown(); }

    long uptime() const { return oscore_get_uptime_seconds(); }
    std::string version() const { return std::string(oscore_version()); }
    std::string cpuinfo() const {
        char buf[16384];
        int n = oscore_get_cpuinfo(buf, sizeof(buf));
        return std::string(buf, (n>0)?n:0);
    }
    std::string meminfo() const {
        char buf[8192];
        int n = oscore_get_meminfo(buf, sizeof(buf));
        return std::string(buf, (n>0)?n:0);
    }
    std::string listBlockDevices() const {
        char buf[8192];
        int n = oscore_list_block_devices(buf, sizeof(buf));
        return std::string(buf, (n>0)?n:0);
    }
    std::string listMounts() const {
        char buf[16384];
        int n = oscore_list_mounts(buf, sizeof(buf));
        return std::string(buf, (n>0)?n:0);
    }
    std::string listNetInterfaces() const {
        char buf[8192];
        int n = oscore_list_net_interfaces(buf, sizeof(buf));
        return std::string(buf, (n>0)?n:0);
    }
    std::string runCommand(const std::string &cmd) const {
        char buf[16384];
        int n = oscore_run_command(cmd.c_str(), buf, sizeof(buf));
        return std::string(buf, (n>0)?n:0);
    }
    int startMonitor(const std::string &logpath) const {
        return oscore_start_event_monitor(logpath.c_str());
    }
    int stopMonitor() const {
        return oscore_stop_event_monitor();
    }
};
}
EOF

##############################
# Java JNI + class
##############################
cat > "${ROOT}/java/com/example/oscore/OSCore.java" <<'EOF'
package com.example.oscore;

public class OSCore {
    static {
        System.loadLibrary("oscore");
    }
    private native long nativeGetUptime();
    private native String nativeVersion();
    private native String nativeCpuInfo();
    private native String nativeMemInfo();
    private native String nativeListBlockDevices();
    private native String nativeListMounts();
    private native String nativeListNetInterfaces();
    private native String nativeRunCommand(String cmd);
    private native int nativeStartMonitor(String logpath);
    private native int nativeStopMonitor();

    public long getUptime() { return nativeGetUptime(); }
    public String version() { return nativeVersion(); }
    public String cpuInfo() { return nativeCpuInfo(); }
    public String memInfo() { return nativeMemInfo(); }
    public String listBlockDevices() { return nativeListBlockDevices(); }
    public String listMounts() { return nativeListMounts(); }
    public String listNetInterfaces() { return nativeListNetInterfaces(); }
    public String runCommand(String cmd) { return nativeRunCommand(cmd); }
    public int startMonitor(String logpath) { return nativeStartMonitor(logpath); }
    public int stopMonitor() { return nativeStopMonitor(); }

    public static void main(String[] args) {
        OSCore c = new OSCore();
        System.out.println("Uptime: " + c.getUptime());
        System.out.println("Versão: " + c.version());
        c.startMonitor("/tmp/oscore_events.log");
        System.out.println("--- NET IFACES ---\\n" + c.listNetInterfaces());
        System.out.println("--- BLOCK ---\\n" + c.listBlockDevices());
        System.out.println("--- RUN pwd ---\\n" + c.runCommand("pwd"));
        System.out.println("Monitor rodando em /tmp/oscore_events.log (verifique com tail -f)");
        // não para a monitor no main automaticamente para permitir ver eventos
    }
}
EOF

cat > "${ROOT}/java/native/OSCore_jni.c" <<'EOF'
#include <jni.h>
#include "../../src/liboscore.h"

JNIEXPORT jlong JNICALL Java_com_example_oscore_OSCore_nativeGetUptime(JNIEnv *env, jobject obj){
    return (jlong) oscore_get_uptime_seconds();
}
JNIEXPORT jstring JNICALL Java_com_example_oscore_OSCore_nativeVersion(JNIEnv *env, jobject obj){
    return (*env)->NewStringUTF(env, oscore_version());
}
JNIEXPORT jstring JNICALL Java_com_example_oscore_OSCore_nativeCpuInfo(JNIEnv *env, jobject obj){
    char buf[16384]; int n = oscore_get_cpuinfo(buf, sizeof(buf));
    if(n<=0) return (*env)->NewStringUTF(env, "");
    return (*env)->NewStringUTF(env, buf);
}
JNIEXPORT jstring JNICALL Java_com_example_oscore_OSCore_nativeMemInfo(JNIEnv *env, jobject obj){
    char buf[8192]; int n = oscore_get_meminfo(buf, sizeof(buf));
    if(n<=0) return (*env)->NewStringUTF(env, "");
    return (*env)->NewStringUTF(env, buf);
}
JNIEXPORT jstring JNICALL Java_com_example_oscore_OSCore_nativeListBlockDevices(JNIEnv *env, jobject obj){
    char buf[8192]; int n = oscore_list_block_devices(buf, sizeof(buf));
    if(n<=0) return (*env)->NewStringUTF(env, "");
    return (*env)->NewStringUTF(env, buf);
}
JNIEXPORT jstring JNICALL Java_com_example_oscore_OSCore_nativeListMounts(JNIEnv *env, jobject obj){
    char buf[16384]; int n = oscore_list_mounts(buf, sizeof(buf));
    if(n<=0) return (*env)->NewStringUTF(env, "");
    return (*env)->NewStringUTF(env, buf);
}
JNIEXPORT jstring JNICALL Java_com_example_oscore_OSCore_nativeListNetInterfaces(JNIEnv *env, jobject obj){
    char buf[8192]; int n = oscore_list_net_interfaces(buf, sizeof(buf));
    if(n<=0) return (*env)->NewStringUTF(env, "");
    return (*env)->NewStringUTF(env, buf);
}
JNIEXPORT jstring JNICALL Java_com_example_oscore_OSCore_nativeRunCommand(JNIEnv *env, jobject obj, jstring jcmd){
    const char *cmd = (*env)->GetStringUTFChars(env, jcmd, NULL);
    char buf[16384];
    int n = oscore_run_command(cmd, buf, sizeof(buf));
    (*env)->ReleaseStringUTFChars(env, jcmd, cmd);
    if(n<=0) return (*env)->NewStringUTF(env, "");
    return (*env)->NewStringUTF(env, buf);
}
JNIEXPORT jint JNICALL Java_com_example_oscore_OSCore_nativeStartMonitor(JNIEnv *env, jobject obj, jstring jpath){
    const char *path = (*env)->GetStringUTFChars(env, jpath, NULL);
    int r = oscore_start_event_monitor(path);
    (*env)->ReleaseStringUTFChars(env, jpath, path);
    return (jint) r;
}
JNIEXPORT jint JNICALL Java_com_example_oscore_OSCore_nativeStopMonitor(JNIEnv *env, jobject obj){
    return (jint) oscore_stop_event_monitor();
}
EOF

##############################
# pkgmanager and firstboot
##############################
cat > "${ROOT}/pkgmanager/packages.manifest" <<'EOF'
# Manifest de aplicativos para instalar automaticamente na primeira inicialização
# Cada linha: package_id [hint]
firefox hint:desktop-browser
settings-app hint:system-settings
mail-app hint:mail-client
EOF

cat > "${ROOT}/pkgmanager/install.sh" <<'EOF'
#!/usr/bin/env bash
# instalador simples: tenta detectar gerenciador do sistema (apt/dnf/pacman)
# se não encontrar, cria "placeholder apps" em ../apps/<package_id>
set -e
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
MANIFEST="$ROOT/pkgmanager/packages.manifest"
APPS_DIR="$ROOT/apps"
mkdir -p "$APPS_DIR"
echo "[oscore-pkg] iniciando instalador automático..."

detect_pkg_manager() {
  if command -v apt-get >/dev/null 2>&1; then echo "apt"; return; fi
  if command -v dnf >/dev/null 2>&1; then echo "dnf"; return; fi
  if command -v pacman >/dev/null 2>&1; then echo "pacman"; return; fi
  echo "none"
}

PKG="$(detect_pkg_manager)"
echo "[oscore-pkg] gerenciador detectado: $PKG"

while read -r line; do
  # remove comentários e espaços
  line="\$(echo \"\$line\" | sed 's/#.*//g' | tr -d '\\r')"
  if [ -z "\$line" ]; then continue; fi
  pkgid=\$(echo \"\$line\" | awk '{print \$1}')
  echo "[oscore-pkg] processando: \$pkgid"
  # se for firefox e existir apt/dnf/pacman, tenta instalar via repositório
  if [ \"\$pkgid\" = \"firefox\" ] && [ \"\$PKG\" != \"none\" ]; then
    echo "[oscore-pkg] tentando instalar firefox via $PKG"
    if [ \"\$PKG\" = \"apt\" ]; then
      sudo apt-get update && sudo apt-get install -y firefox || true
    elif [ \"\$PKG\" = \"dnf\" ]; then
      sudo dnf install -y firefox || true
    elif [ \"\$PKG\" = \"pacman\" ]; then
      sudo pacman -Sy --noconfirm firefox || true
    fi
    # se o binário firefox não existir, cria placeholder
    if [ ! -x \"$(which firefox 2>/dev/null || echo /usr/bin/firefox)\" ]; then
      echo "[oscore-pkg] firefox não instalado via pacote, criando placeholder"
      mkdir -p \"$APPS_DIR/firefox\"
      cat > \"$APPS_DIR/firefox/run.sh\" <<'SH'
#!/usr/bin/env bash
echo "Firefox placeholder: este sistema não instalou o Firefox automaticamente."
echo "Use o gerenciador de pacotes da sua distro para instalar o Firefox real."
SH
      chmod +x \"$APPS_DIR/firefox/run.sh\"
    fi
    continue
  fi
  # demais pacotes: criar placeholder apps (settings, mail)
  mkdir -p \"$APPS_DIR/\$pkgid\"
  cat > \"$APPS_DIR/\$pkgid/run.sh\" <<'SH'
#!/usr/bin/env bash
echo "App placeholder: \$pkgid"
echo "Este é um app nativo placeholder criado pelo instalador."
SH
  chmod +x \"$APPS_DIR/\$pkgid/run.sh\"
done < \"$MANIFEST\"

echo "[oscore-pkg] instalação concluída."
EOF
chmod +x "${ROOT}/pkgmanager/install.sh"

cat > "${ROOT}/firstboot.sh" <<'EOF'
#!/usr/bin/env bash
# Script de primeira inicialização: instala apps do manifest e cria flag
ROOT="$(cd "$(dirname "$0")" && pwd)"
FLAG="/.oscore_firstboot_done"
if [ -f "$FLAG" ]; then
  echo "Firstboot já executado."
  exit 0
fi
echo "Executando primeira instalação de apps..."
"$ROOT/pkgmanager/install.sh"
touch "$FLAG"
echo "Firstboot concluído."
EOF
chmod +x "${ROOT}/firstboot.sh"

##############################
# apps placeholders
##############################
mkdir -p "${ROOT}/apps/settings" "${ROOT}/apps/mail" "${ROOT}/apps/firefox"
cat > "${ROOT}/apps/settings/run.sh" <<'EOF'
#!/usr/bin/env bash
echo "Settings app placeholder"
echo "Aqui você implementará a interface de configurações (futura UI Java/Kotlin)."
EOF
chmod +x "${ROOT}/apps/settings/run.sh"

cat > "${ROOT}/apps/mail/run.sh" <<'EOF'
#!/usr/bin/env bash
echo "Mail app placeholder"
echo "Este é o app de email nativo placeholder."
EOF
chmod +x "${ROOT}/apps/mail/run.sh"

cat > "${ROOT}/apps/firefox/run.sh" <<'EOF'
#!/usr/bin/env bash
echo "Firefox placeholder app"
echo "Se o Firefox não estiver instalado no sistema, use o gerenciador de pacotes para instalar o real."
EOF
chmod +x "${ROOT}/apps/firefox/run.sh"

##############################
# systemd unit templates
##############################
cat > "${ROOT}/units/oscore-firstboot.service" <<'EOF'
[Unit]
Description=OSCore First Boot Installer
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/oscore-firstboot.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

cat > "${ROOT}/units/oscore-monitor.service" <<'EOF'
[Unit]
Description=OSCore Event Monitor
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/oscore-monitor.sh
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF

##############################
# build system: CMakeLists.txt + build.sh
##############################
cat > "${ROOT}/CMakeLists.txt" <<'EOF'
cmake_minimum_required(VERSION 3.10)
project(oscore_advanced C)

set(CMAKE_C_STANDARD 11)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

# sources
set(MONITOR_SRC src/monitor/netlink_monitor.c)
set(OSCORE_SRC src/liboscore.c)

add_library(oscore SHARED \${OSCORE_SRC} \${MONITOR_SRC})
target_include_directories(oscore PUBLIC src)
find_package(Threads REQUIRED)
target_link_libraries(oscore PUBLIC Threads::Threads)

# JNI
find_package(Java QUIET)
find_package(JNI QUIET)
if(JNI_FOUND)
    include_directories(\${JNI_INCLUDE_DIRS})
    add_library(oscore_jni SHARED java/native/OSCore_jni.c)
    target_link_libraries(oscore_jni oscore)
    set_target_properties(oscore_jni PROPERTIES PREFIX "")
else()
    message(WARNING "JNI not found: skipping JNI build")
endif()

install(TARGETS oscore DESTINATION lib)
EOF

cat > "${ROOT}/build.sh" <<'EOF'
#!/usr/bin/env bash
set -e
mkdir -p build
cd build
cmake ..
cmake --build .
echo
echo "Build finalizado."
echo "Se JNI foi encontrado, liboscore_jni (JNI bridge) foi gerada."
echo "Para testar Java (exemplo):"
echo "  export LD_LIBRARY_PATH=$(pwd):\$LD_LIBRARY_PATH"
echo "  javac ../java/com/example/oscore/OSCore.java"
echo "  java -cp ../java com.example.oscore.OSCore"
EOF
chmod +x "${ROOT}/build.sh"

##############################
# helper scripts to install firstboot and monitor into /usr/local/bin (manual step)
##############################
cat > "${ROOT}/install_local_bins.sh" <<'EOF'
#!/usr/bin/env bash
set -e
ROOT="$(cd "$(dirname "$0")" && pwd)"
# copy firstboot and monitor launcher scripts to /usr/local/bin (requires sudo)
sudo cp "$ROOT/firstboot.sh" /usr/local/bin/oscore-firstboot.sh
sudo cp "$ROOT/pkgmanager/install.sh" /usr/local/bin/oscore-pkg-install.sh
# create monitor launcher that uses java example or binary
cat > /tmp/oscore-monitor.sh <<'SH'
#!/usr/bin/env bash
# simples wrapper que inicia monitor de eventos (espera ter liboscore no LD_LIBRARY_PATH)
export LD_LIBRARY_PATH=/usr/local/lib:\$LD_LIBRARY_PATH
# Podemos rodar um pequeno programa em C que invoque startMonitor, mas aqui
# apenas apontamos instruções: o usuário deve garantir que liboscore.so esteja em /usr/local/lib
echo "Para rodar o monitor, execute: (no diretório do build) LD_LIBRARY_PATH=/path/to/build ./your_monitor_client"
SH
sudo mv /tmp/oscore-monitor.sh /usr/local/bin/oscore-monitor.sh
sudo chmod +x /usr/local/bin/oscore-firstboot.sh /usr/local/bin/oscore-pkg-install.sh /usr/local/bin/oscore-monitor.sh
echo "Instalados binários locais (scripts) em /usr/local/bin. Ajuste conforme necessário."
EOF
chmod +x "${ROOT}/install_local_bins.sh"

##############################
# rust skeleton (unchanged minimal)
##############################
cat > "${ROOT}/rust/Cargo.toml" <<'EOF'
[package]
name = "oscore_rust"
version = "0.1.0"
edition = "2021"

[lib]
name = "oscore_rust"
crate-type = ["cdylib"]

[dependencies]
libc = "0.2"
EOF

cat > "${ROOT}/rust/src/lib.rs" <<'EOF'
use libc::c_long;
extern "C" {
    fn oscore_get_uptime_seconds() -> c_long;
}

#[no_mangle]
pub extern "C" fn rust_get_uptime() -> c_long {
    unsafe { oscore_get_uptime_seconds() }
}
EOF

##############################
# NOTICE
##############################
cat > "${ROOT}/NOTICE.txt" <<'EOF'
NOTAS IMPORTANTES:

- Este projeto cria um monitor que lê eventos do kernel via netlink/uevent. Execute em ambiente seguro.
- O instalador tenta usar apt/dnf/pacman se disponíveis; caso contrário, cria placeholders para apps.
- Não inclua binários proprietários no repositório sem checar licenças.
- Se for distribuir produto com kernel modificado, consulte advogado sobre GPL.
EOF

##############################
# final
##############################
echo "Projeto avançado gerado em ./${ROOT} com:"
echo " - liboscore C + monitor netlink/uevent"
echo " - wrappers C++"
echo " - JNI/Java/Kotlin skeleton"
echo " - pkgmanager + firstboot autoinstall (manifest)"
echo " - placeholders de apps (settings, mail, firefox)"
echo " - systemd unit templates"
echo
echo "Próximo passo sugerido:"
echo "  cd ${ROOT}"
echo "  ./build.sh"
echo
echo 
echo
echo 
